// Copyright (c) 2024 the authors
// Use of this source code is governed by a MIT license found in the LICENSE file.

package assistant

import (
	"encoding/json"
	"fmt"
	"io"

	"github.com/ktong/assistant/internal/embedded"
)

const (
	// RoleUser indicates the message is sent by an actual user and
	// should be used in most cases to represent user-generated messages.
	RoleUser Role = "user"
	// RoleAssistant indicates the message is generated by the assistant.
	// Use this value to insert messages from the assistant into the conversation.
	RoleAssistant Role = "assistant"
)

const (
	DetailAuto Detail = "auto"
	DetailHigh Detail = "high"
	DetailLow  Detail = "low"
)

type (
	Message struct {
		ID      string
		Role    Role
		Content []Content
		Tools   []Tool
	}
	Role    string
	Content interface {
		embedded.Content
	}

	// Text content that is part of a message.
	Text struct {
		embedded.Content

		Text string
	}

	// Image is a references an image File or URL in the content of a message.
	// It's only supported on Vision-compatible models.
	Image[F string | []byte] struct {
		embedded.Content

		URL F
		// Detail specifies the detail level of the image.
		Detail Detail
	}
	Detail string

	// File is used to upload documents that can be used with tools.
	File struct {
		ID     string
		Name   string
		Reader io.Reader
	}
)

func toMessage[T any](s T) (Message, error) {
	var content Content
	// TODO: cover more cases
	switch value := any(s).(type) {
	case Content:
		content = value
	case string:
		content = Text{Text: value}
	default:
		jsonBytes, err := json.Marshal(value)
		if err != nil {
			return Message{}, fmt.Errorf("marshal as text content: %w", err)
		}

		content = Text{Text: string(jsonBytes)}
	}

	return Message{Role: RoleUser, Content: []Content{content}}, nil
}

func fromMessage[T any](c Message) (T, error) { //nolint:ireturn
	// TODO: cover more cases
	switch content := c.Content[0].(type) {
	case Text:
		text := new(T)
		switch value := any(text).(type) {
		case *string:
			*value = content.Text
		default:
			if err := json.Unmarshal([]byte(content.Text), text); err != nil {
				return *new(T), fmt.Errorf("unmarshal text content: %w", err)
			}
		}

		return *text, nil
	default:
		return *new(T), fmt.Errorf("unsupported content type: %T", content) //nolint:err113
	}
}
